# -*- coding: utf-8 -*-
"""Assi2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1N4qcHJYIpHhdYxcGuKD5HegL0tATQ0wM

#ISD Question 8

The code below has 3 different subexperiments. It uses python librarires for finding different combinations of the Info set. There are 2 approaches. Taking random Info set and second trying all combinations of ISD 1 by 1. The last part is an example taking a small code and decoding the error.
"""
########IMPORTS###################
import numpy as np
import itertools
import random
from collections import namedtuple
#####################################
Stats = namedtuple("Stats", ["trials", "non_invertible", "found", "info_set"])
######################INVERSE FUNCTION FOR Finding Inverse in F2##################
def gf2_inverse(A):
    A = A.copy().astype(int) % 2
    n = A.shape[0]
    aug = np.concatenate([A, np.eye(n, dtype=int)], axis=1)
    row = 0
    for col in range(n):
        pivot = None
        for r in range(row, n):
            if aug[r, col] == 1:
                pivot = r
                break
        if pivot is None:
            continue
        if pivot != row:
            aug[[pivot, row]] = aug[[row, pivot]]
        for r in range(n):
            if r != row and aug[r, col] == 1:
                aug[r] ^= aug[row]
        row += 1
        if row == n:
            break
    if row < n:
        return None
    return aug[:, n:] % 2

def encode_message(x, G):
    return (x @ G) % 2
#########################RANDOM SAMPLING OF I############################################
def isd_search(G, y, k, t, max_trials=100000, random_seed=None):
    if random_seed is not None:
        random.seed(random_seed)
        np.random.seed(random_seed)
    n = G.shape[1]
    trials = 0
    non_invertible = 0
    indices = list(range(n))
    tried_sets = set()
    while trials < max_trials:
        I = tuple(sorted(random.sample(indices, k)))
        if I in tried_sets:
            continue
        tried_sets.add(I)
        trials += 1
        G1 = G[:, list(I)]
        Q1 = gf2_inverse(G1)
        if Q1 is None:
            non_invertible += 1
            continue
        Q2 = (Q1 @ G) % 2
        c1 = np.array([y[i] for i in I])
        m1 = (y + (c1 @ Q2) % 2) % 2
        if np.count_nonzero(m1) == t:
            return m1.astype(int), Stats(trials, non_invertible, True, [i+1 for i in I])
    return None, Stats(trials, non_invertible, False, None)
##########################COMBINATORIAL SAMPLING I##################################################
def isd_systematic(G, y, k, t, max_combinations=None):
    trials = 0
    non_invertible = 0
    n = G.shape[1]
    for combo in itertools.combinations(range(n), k):
        trials += 1
        G1 = G[:, list(combo)]
        Q1 = gf2_inverse(G1)
        if Q1 is None:
            non_invertible += 1
            continue
        Q2 = (Q1 @ G) % 2
        c1 = np.array([y[i] for i in combo])
        m1 = (y + (c1 @ Q2) % 2) % 2
        if np.count_nonzero(m1) == t:
            return m1.astype(int), Stats(trials, non_invertible, True, [i+1 for i in combo])
        if max_combinations and trials >= max_combinations:
            break
    return None, Stats(trials, non_invertible, False, None)
########################################################################################################
# INPUT SECTION
n = 16
k = 8
G = np.array([
    [1,0,1,0,1,0,0,0,1,1,1,1,0,0,0,1],
    [1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,1],
    [0,1,0,0,1,0,0,0,0,0,1,1,0,1,1,0],
    [1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0],
    [1,0,0,1,1,0,1,0,0,0,1,1,1,1,0,1],
    [0,0,1,0,0,1,1,1,0,0,0,0,1,1,0,1],
    [0,0,0,1,0,0,0,0,1,0,1,1,1,1,0,0],
    [0,0,1,0,1,1,0,0,0,1,1,1,1,0,1,0]
], dtype=int)

x = np.array([0,1,1,1,0,0,1,1], dtype=int)
e = np.array([0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0], dtype=int)
t = 2
y = (encode_message(x, G) + e) % 2

#############Radndom sample input##########################################
print("Randomized ISD search (example):")
decoded, stats = isd_search(G, y, k=k, t=t, max_trials=20000)
print("Found:", decoded is not None)
print("Trials:", stats.trials, "Non-invertible:", stats.non_invertible)
if decoded is not None:
    print("Decoded error:", decoded)
    print("Verification OK:", np.array_equal((encode_message(x, G) + decoded) % 2, y))

###########Combinatorial Input#######################
print("\nSystematic (combinatorial) ISD search (example):")
decoded_sys, stats_sys = isd_systematic(G, y, k=k, t=t, max_combinations=200000)
print("Found:", decoded_sys is not None)
print("Trials:", stats_sys.trials, "Non-invertible:", stats_sys.non_invertible)
if decoded_sys is not None:
    print("Decoded error:", decoded_sys)
    print("Info set:", stats_sys.info_set)

#######Random Example##############
print("\nRandom small-code test:")
def random_full_rank_G(k, n, seed=None):
    if seed is not None:
        np.random.seed(seed)
    while True:
        G = np.random.randint(0,2,(k,n))
        if np.linalg.matrix_rank(G % 2) == k:
            return G % 2

k2, n2, t2 = 4, 8, 1
G2 = random_full_rank_G(k2, n2, seed=1)
x2 = np.random.randint(0,2,k2)
e2 = np.zeros(n2, dtype=int); e2[3] = 1
y2 = (encode_message(x2, G2) + e2) % 2

decoded2, stats2 = isd_search(G2, y2, k=k2, t=t2, max_trials=1000, random_seed=7)
print("Found:", decoded2 is not None)
print("Trials:", stats2.trials, "Non-invertible:", stats2.non_invertible)
if decoded2 is not None:
    print("Decoded error:", decoded2)
    print("Verification OK:", np.array_equal((encode_message(x2, G2) + decoded2) % 2, y2))

print(x2)
print(e2)

# import numpy as np
# import itertools
# import random

# # ---------- PARAMETERS ----------
# n = 16   # code length
# k = 8    # message length
# t = 2    # target weight

# # ---------- GENERATOR MATRIX ----------
# G = np.array([
#     [1,0,1,0,1,0,0,0,1,1,1,1,0,0,0,1],
#     [1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,1],
#     [0,1,0,0,1,0,0,0,0,0,1,1,0,1,1,0],
#     [1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0],
#     [1,0,0,1,1,0,1,0,0,0,1,1,1,1,0,1],
#     [0,0,1,0,0,1,1,1,0,0,0,0,1,1,0,1],
#     [0,0,0,1,0,0,0,0,1,0,1,1,1,1,0,0],
#     [0,0,1,0,1,1,0,0,0,1,1,1,1,0,1,0]
# ], dtype=int)

# # ---------- INPUT MESSAGE & ERROR ----------
# x = np.array([0,1,1,1,0,0,1,1])
# e = np.array([0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0])

# # ----------FUNCTIONS ----------
# def find_det(A):
#     return int(round(np.linalg.det(A))) % 2

# def find_inv(A):
#     A = A.copy().astype(int)
#     n = len(A)
#     A = np.concatenate((A, np.eye(n, dtype=int)), axis=1)
#     for i in range(n):
#         if A[i, i] == 0:
#             for j in range(i+1, n):
#                 if A[j, i] == 1:
#                     A[[i, j]] = A[[j, i]]
#                     break
#         A[i] = A[i] % 2
#         for j in range(n):
#             if j != i and A[j, i] == 1:
#                 A[j] = (A[j] + A[i]) % 2
#     return A[:, n:]

# def Hweight(vec):
#     return np.count_nonzero(vec)

# y = (np.dot(x, G) % 2 + e) % 2

# found = False

# # random subset
# indices = list(range(1, n+1))
# random.shuffle(indices)

# # Generate all possible k-subsets, starting near the random index
# for combo in itertools.combinations(indices, k):
#     I = sorted(combo)
#     G1 = np.array([G[:, i-1] for i in I]).T
#     c1 = np.array([y[i-1] for i in I])

#     if find_det(G1) != 0:
#         Q1 = find_inv(G1)
#         Q2 = np.dot(Q1, G) % 2
#         m1 = (y + np.dot(c1, Q2)) % 2
#         if Hweight(m1) == t:
#             print(f"Found valid info set: {I}")
#             print(f"Decoded error vector: {m1}")
#             found = True
#             break

# if not found:
#     print("No valid information set found with weight =", t)

# """#Question 6 calculations"""

# import numpy as np

# G = np.array([
#     [1,0,0,0,0,0,0,0,1,0,0,1,0,1,0,1],
#     [0,1,0,0,0,0,0,0,1,0,1,0,0,1,1,0],
#     [0,0,1,0,0,0,0,0,1,1,0,0,0,0,1,1],
#     [0,0,0,1,0,0,0,0,1,1,1,0,1,0,0,0],
#     [0,0,0,0,1,0,0,0,0,1,0,1,1,1,0,0],
#     [0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1],
#     [0,0,0,0,0,0,1,0,0,0,1,1,1,1,1,1],
#     [0,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0]
# ], dtype=int)
# S = np.array([
#     [0,0,1,0,0,1,1,0],
#     [1,0,1,0,1,0,1,0],
#     [0,0,0,0,0,1,0,0],
#     [1,1,0,0,0,0,0,0],
#     [0,1,0,1,0,1,0,1],
#     [1,1,1,1,1,0,0,0],
#     [0,0,0,1,0,1,0,1],
#     [0,0,1,1,1,1,1,0]
# ], dtype=int)
# import numpy as np

# perm = [10, 12, 2, 7, 14, 4, 1, 0, 8, 6, 5, 15,3, 9, 11, 13]

# n = len(perm)
# P = np.zeros((n, n), dtype=int)
# for i, j in enumerate(perm):
#     P[j, i] = 1

# H = np.array([
#     [0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1],
#     [0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1],
#     [1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0],
#     [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1],
#     [1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0],
#     [0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1],
#     [0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1],
#     [1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0]
# ], dtype=np.int8)

# print("H matrix shape:", H.shape)
# print(H)


# G_hat=np.matmul(np.matmul(S,G)%2,P)%2

# G_hat

# x=(0,0,1,1,1,1,0,1)
# e=(0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0)

# c=(np.matmul(x,G_hat)%2+e)%2

# c

# pip install galois

# import numpy as np
# import galois

# def find_inv(G):
#   GF2 = galois.GF(2)

#   A = GF2(G)
#   A_inv = np.linalg.inv(A)
#   return np.array(A_inv)
# pinv=find_inv(P)

# sinv=find_inv(S)
# H1=np.matmul(np.matmul(S,H)%2,P)%2

# H1

# c1=np.matmul(c,pinv)%2

# x=(0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0)
# cneidetter=np.matmul(H1,np.transpose(x))%2

# cneidetter
# SinvC=np.matmul(sinv,cneidetter)%2

# SinvC

# H= np.array([
#     [0,1,0,1,1,0,0,1,0,1,1,1,1,0,0,1],
#     [0,0,0,0,0,1,0,1,1,0,1,0,0,0,0,1],
#     [1,1,0,0,0,1,0,1,1,1,1,1,1,1,0,0],
#     [0,0,0,0,0,0,1,1,0,0,1,1,1,0,1,1],
#     [1,0,1,1,0,0,1,0,0,1,0,1,0,0,0,0],
#     [0,0,0,1,1,0,1,0,1,1,1,1,0,1,1,1],
#     [0,1,0,1,0,1,1,0,1,0,0,0,0,0,0,1],
#     [1,1,1,1,1,1,1,1,0,1,1,1,1,0,0,0]
# ], dtype=int)

# s=np.matmul(c,np.transpose(H))%2

# s

# c

# #Loop to find PxT
# def binary_t_weight_vectors(n, t):
#     vectors = []
#     for positions in itertools.combinations(range(n), t):
#         vec = [0] * n
#         for p in positions:
#             vec[p] = 1
#         vectors.append(tuple(vec))
#     return vectors

# n = 16
# t = 2
# result = binary_t_weight_vectors(n, t)
# for r in result:
#   x1=np.array(r)
#   Hx1=np.matmul(H,x1)%2
#   if np.array_equal(Hx1, SinvC):
#     break

# np.matmul(pinv,r)%2
